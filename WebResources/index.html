<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body { margin: 0; overflow: hidden; background: transparent; }
      canvas { width: 100% !important; height: 100% !important; display: block; }
    </style>
    <script type="importmap">
      {
          "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
              "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js",
              "@pixiv/three-vrm-animation": "https://unpkg.com/@pixiv/three-vrm-animation@3.0.0/lib/three-vrm-animation.module.js"
          }
      }
    </script>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { VRMLoaderPlugin } from '@pixiv/three-vrm';
      import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 20.0);

      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // 光照
      const light = new THREE.DirectionalLight(0xffffff, 1.2);
      light.position.set(1.0, 1.0, 1.0).normalize();
      scene.add(light);
      scene.add(new THREE.AmbientLight(0xffffff, 0.8));

      // 状态变量
      // activeMode: 'head' 代表折叠(灵动岛)状态, 'body' 代表展开状态
      let activeMode = 'head';
      let currentVrm = null;
      let currentMixer = null;

      // 摄像机目标
      let targetCamPos = new THREE.Vector3(0, 1.4, 0.6);
      let targetLookAt = new THREE.Vector3(0, 1.4, 0);
      const currentLookAt = new THREE.Vector3(0, 1.4, 0);

      // 交互变量
      let mouseX = 0;
      let mouseY = 0;
      let currentYaw = 0;
      let currentPitch = 0;
      let bodyFitDistance = 1.5;

      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));
      loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

      loader.load('./avatar.vrm', (gltf) => {
          const vrm = gltf.userData.vrm;
          vrm.scene.rotation.y = Math.PI; // 模型转身面向镜头
          scene.add(vrm.scene);
          currentVrm = vrm;

          // 开启 LookAt 辅助眼球转动
          const lookAtTarget = new THREE.Object3D();
          scene.add(lookAtTarget);
          vrm.lookAt.target = lookAtTarget;

          calculateBodyFitDistance(vrm);

          loader.load('./idle.vrma', (gltfAnim) => {
              const clips = gltfAnim.userData.vrmAnimations;
              if (clips && clips[0]) {
                  currentMixer = new THREE.AnimationMixer(vrm.scene);
                  const clip = createVRMAnimationClip(clips[0], vrm);
                  currentMixer.clipAction(clip).play();
              }
          });
      });

      function calculateBodyFitDistance(vrm) {
          const headNode = vrm.humanoid.getRawBoneNode("head");
          const hipsNode = vrm.humanoid.getRawBoneNode("hips");
          if (!headNode || !hipsNode) return;

          vrm.scene.updateMatrixWorld(true);
          const headY = headNode.getWorldPosition(new THREE.Vector3()).y;
          const hipsY = hipsNode.getWorldPosition(new THREE.Vector3()).y;
          const visibleHeight = (headY + 0.18) - (hipsY + 0.15);
          const fovRad = (camera.fov * Math.PI) / 180;
          bodyFitDistance = (visibleHeight / 2) / Math.tan(fovRad / 2) * 1.5;
      }

      const clock = new THREE.Clock();

      function animate() {
          requestAnimationFrame(animate);
          const delta = clock.getDelta();

          if (currentVrm) {
              // 1. 基础动画更新
              if (currentMixer) currentMixer.update(delta);
              currentVrm.update(delta);

              // 2. 头部跟随鼠标 (Fix: 折叠状态下减小幅度)
              const sensitivity = 0.002;
              const maxYaw = THREE.MathUtils.degToRad(50);
              const maxPitch = THREE.MathUtils.degToRad(30);

              // [关键修改]：判断当前模式
              // 如果是 'head' (折叠/灵动岛模式)，将追踪强度降低到 25%
              // 这样即使鼠标在屏幕最下方，头也只会微微向下，不会变成“埋头”
              const isClosedMode = (activeMode === 'head');
              const trackingIntensity = isClosedMode ? 0.25 : 1.0;

              // 计算目标角度（应用强度系数）
              const targetYaw = THREE.MathUtils.clamp(
                  mouseX * sensitivity * trackingIntensity,
                  -maxYaw * trackingIntensity,
                  maxYaw * trackingIntensity
              );
              const targetPitch = THREE.MathUtils.clamp(
                  mouseY * sensitivity * trackingIntensity,
                  -maxPitch * trackingIntensity,
                  maxPitch * trackingIntensity
              );

              currentYaw = THREE.MathUtils.lerp(currentYaw, targetYaw, 0.1);
              currentPitch = THREE.MathUtils.lerp(currentPitch, targetPitch, 0.1);

              const head = currentVrm.humanoid.getRawBoneNode('head');
              const neck = currentVrm.humanoid.getRawBoneNode('neck');
              const spine = currentVrm.humanoid.getRawBoneNode('upperChest') || currentVrm.humanoid.getRawBoneNode('chest');

              if (spine) {
                  spine.rotation.y += currentYaw * 0.2;
                  spine.rotation.x += currentPitch * 0.2;
              }
              if (neck) {
                  neck.rotation.y += currentYaw * 0.3;
                  neck.rotation.x += currentPitch * 0.3;
              }
              if (head) {
                  head.rotation.y += currentYaw * 0.5;
                  head.rotation.x += currentPitch * 0.5;
              }

              // 3. 摄像机跟随
              currentVrm.scene.updateMatrixWorld();

              const headPos = head.getWorldPosition(new THREE.Vector3());
              let hipsPos = new THREE.Vector3(headPos.x, headPos.y * 0.55, headPos.z);
              const hipsNode = currentVrm.humanoid.getRawBoneNode("hips");
              if (hipsNode) hipsPos = hipsNode.getWorldPosition(new THREE.Vector3());

              if (activeMode === 'head') {
                   // [Head Mode] 紧跟头部 (折叠状态)
                   targetLookAt.set(headPos.x, headPos.y + 0.05, headPos.z);
                   targetCamPos.set(headPos.x, headPos.y + 0.05, headPos.z + 0.55);
              } else {
                   // [Body Mode] 全身/半身 (展开状态)
                   const viewCenterY = (headPos.y + 0.18 + hipsPos.y + 0.15) / 2;
                   targetLookAt.set(headPos.x, viewCenterY, headPos.z);
                   targetCamPos.set(headPos.x, viewCenterY, headPos.z + bodyFitDistance);
              }

              // 4. LookAt 辅助体
              if (currentVrm.lookAt && currentVrm.lookAt.target) {
                   currentVrm.lookAt.target.position.set(
                        headPos.x + Math.sin(currentYaw),
                        headPos.y + Math.tan(currentPitch),
                        headPos.z + Math.cos(currentYaw)
                   );
              }
          }

          // 摄像机平滑
          camera.position.lerp(targetCamPos, 0.05);
          currentLookAt.lerp(targetLookAt, 0.05);
          camera.lookAt(currentLookAt);

          renderer.render(scene, camera);
      }
      animate();

      window.updateMouseParams = (dx, dy) => {
          mouseX = dx;
          mouseY = dy;
      };

      window.setCameraMode = (mode) => { activeMode = mode; };

      // === 3. 移除旧的 window.updateSize 依赖，改为自动监听 ===

        // 定义更新函数
        const handleResize = (width, height) => {
      if (width === 0 || height === 0) return;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio); // 每次调整都确保像素比正确

      // 触发一次额外渲染，防止闪烁
      renderer.render(scene, camera);
        };

        // 核心修复：创建 ResizeObserver
        // 只要 body 尺寸发生微小变化，这个回调就会触发
        const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
          // 获取最新的精确尺寸
          const { width, height } = entry.contentRect;
          handleResize(width, height);
      }
        });

        // 开始监听 body
        resizeObserver.observe(document.body);

        // 兼容性：保留 updateSize 接口以防 Swift 强行调用，但主要依赖 Observer
        window.updateSize = (w, h) => {
      // 可以在这里打个 log 看看 Swift 传了什么，通常 Observer 已经处理了
      handleResize(w, h);
        };
    </script>
  </body>
</html>
