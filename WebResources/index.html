<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body { margin: 0; padding: 0; overflow: hidden; background: transparent; width: 100vw; height: 100vh; }
      canvas { display: block; width: 100% !important; height: 100% !important; touch-action: none; }
    </style>
    <script type="importmap">
      {
          "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
              "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js",
              "@pixiv/three-vrm-animation": "https://unpkg.com/@pixiv/three-vrm-animation@3.0.0/lib/three-vrm-animation.module.js"
          }
      }
    </script>
  </head>
  <body>
    <script>
      function log(msg) {
          const el = document.getElementById('debug-console');
          if(el) el.innerText += '\n' + msg;
          console.log(msg);
      }
      window.onerror = function(msg, url, line) { log("❌ Error: " + msg + " (" + line + ")"); };
      log("DOM Loaded.");
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
      import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

      log("Three.js Modules Imported.");

      try {
          const scene = new THREE.Scene();
          // FOV 40 适合人像
          const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 20.0);
          const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          document.body.appendChild(renderer.domElement);

          const light = new THREE.DirectionalLight(0xffffff, 1.2);
          light.position.set(0.5, 1.0, 1.0).normalize();
          scene.add(light);
          scene.add(new THREE.AmbientLight(0xffffff, 0.6));

          // === 摄像机控制变量 ===
          let activeMode = 'head'; // 当前模式
          let bodyFitDistance = 1.5; // Body 模式下计算出的最佳距离

          // 目标位置 (Lerp 的终点)
          let targetCamPos = new THREE.Vector3(0, 1.5, 1.0);
          let targetLookAt = new THREE.Vector3(0, 1.5, 0);

          // 当前实际视点 (用于平滑 LookAt)
          let currentLookAt = new THREE.Vector3(0, 1.5, 0);

          let currentMixer = null;

          // === Loader ===
          const loader = new GLTFLoader();
          loader.register((parser) => new VRMLoaderPlugin(parser));
          loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

          loader.load('./avatar.vrm', (gltf) => {
              const vrm = gltf.userData.vrm;
              vrm.scene.rotation.y = Math.PI;
              scene.add(vrm.scene);
              window.currentVrm = vrm;
              log("✅ VRM Loaded.");

              // 预计算 Body 模式的最佳距离 (只计算一次距离参数，位置实时跟)
              calculateBodyFitDistance(vrm);

              // 加载动画
              loadIdleAnimation(vrm);

              // 隐藏 Debug UI
              setTimeout(() => {
                  const el = document.getElementById('debug-console');
                  if(el) el.style.display = 'none';
              }, 2000);

          }, undefined, (err) => log("❌ VRM Error: " + err.message));

          function loadIdleAnimation(vrm) {
              loader.load('./idle.vrma', (gltf) => {
                  const vrmAnimations = gltf.userData.vrmAnimations;
                  if (vrmAnimations && vrmAnimations[0]) {
                      currentMixer = new THREE.AnimationMixer(vrm.scene);
                      const clip = createVRMAnimationClip(vrmAnimations[0], vrm);
                      currentMixer.clipAction(clip).play();
                  }
              });
          }

          function calculateBodyFitDistance(vrm) {
              const headNode = vrm.humanoid.getRawBoneNode("head");
              const hipsNode = vrm.humanoid.getRawBoneNode("hips");
              if (!headNode || !hipsNode) return;

              // 临时获取静态位置计算高度差
              const headY = headNode.getWorldPosition(new THREE.Vector3()).y;
              const hipsY = hipsNode.getWorldPosition(new THREE.Vector3()).y;

              const viewTop = headY + 0.18;
              const viewBottom = hipsY + 0.15;
              const visibleHeight = viewTop - viewBottom;

              // 公式反推距离
              const fovRad = (camera.fov * Math.PI) / 180;
              bodyFitDistance = (visibleHeight / 2) / Math.tan(fovRad / 2) * 1.5;
              log("Calculated Body Dist: " + bodyFitDistance.toFixed(2));
          }

          // === 动画循环 (核心修改) ===
          const clock = new THREE.Clock();
          let blinkTimer = 0;
          let nextBlinkTime = 2;
          let isBlinking = false;

          function animate() {
              requestAnimationFrame(animate);
              const delta = clock.getDelta();

              if (window.currentVrm) {
                  const vrm = window.currentVrm;

                  // 1. 更新动画 (人物动起来)
                  if (currentMixer) currentMixer.update(delta);
                  // if (vrm.expressionManager) updateBlink(vrm, delta);
                  vrm.update(delta);

                  // 2. 实时获取骨骼位置 (跟随的核心)
                  const headNode = vrm.humanoid.getRawBoneNode("head");
                  const hipsNode = vrm.humanoid.getRawBoneNode("hips");

                  if (headNode) {
                      const headPos = headNode.getWorldPosition(new THREE.Vector3());

                      // 如果没有 hips，用 head 下方估算
                      let hipsPos = new THREE.Vector3(headPos.x, headPos.y * 0.55, headPos.z);
                      if (hipsNode) hipsPos = hipsNode.getWorldPosition(new THREE.Vector3());

                      // === 动态计算目标点 ===
                      if (activeMode === 'head') {
                          // [HEAD MODE] 紧跟头部
                          // 目标：看着脸中心 (head + 0.05)
                          targetLookAt.set(headPos.x, headPos.y + 0.05, headPos.z);
                          // 相机：在脸前方 0.55 米
                          targetCamPos.set(headPos.x, headPos.y + 0.05, headPos.z + 0.55);

                      } else {
                          // [BODY MODE] 跟随躯干中心
                          const viewCenterY = (headPos.y + 0.18 + hipsPos.y + 0.15) / 2; // 动态计算中心

                          targetLookAt.set(headPos.x, viewCenterY, headPos.z);
                          // 相机：保持预计算的构图距离
                          targetCamPos.set(headPos.x, viewCenterY, headPos.z + bodyFitDistance);
                      }
                  }
              }

              // 3. 摄像机平滑阻尼 (让跟随像云台一样丝滑)
              // 调小 damping (如 0.05) 会更延迟/平滑，调大 (如 0.2) 会更跟手
              const damping = 0.05;

              camera.position.lerp(targetCamPos, damping);
              currentLookAt.lerp(targetLookAt, damping);
              camera.lookAt(currentLookAt);

              renderer.render(scene, camera);
          }
          animate();

          // === 对外接口 ===
          window.setCameraMode = (mode) => {
              log("Mode switch: " + mode);
              activeMode = mode;
              // 切换模式时不强制瞬移，利用 animate 中的 lerp 实现平滑过渡
          };

          window.updateSize = (w, h) => {
              camera.aspect = w / h;
              camera.updateProjectionMatrix();
              renderer.setSize(w, h);
          };

      } catch (e) { log("❌ Crash: " + e.message); }
    </script>
  </body>
</html>
