<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          background: transparent;
          width: 100vw;
          height: 100vh;
      }
      canvas {
          display: block;
          width: 100% !important;
          height: 100% !important;
          touch-action: none;
      }
    </style>
    <script type="importmap">
      {
          "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
              "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js"
          }
      }
    </script>
  </head>
  <body>
    <!-- <div id="debug-console" style="position:absolute; top:0; left:0; color:lime; background:rgba(0,0,0,0.5); font-family:monospace; font-size:12px; pointer-events:none; z-index:999;">Initializing...</div> -->
    <script>
      function log(msg) {
          const el = document.getElementById('debug-console');
          if(el) el.innerText += '\n' + msg;
          console.log(msg);
      }
      window.onerror = function(msg, url, line) {
          log("❌ Error: " + msg + " (" + line + ")");
      };
      log("DOM Loaded.");
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

      log("Three.js Modules Imported.");

      try {
          const scene = new THREE.Scene();

          const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 20.0);
          const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          document.body.appendChild(renderer.domElement);

          const light = new THREE.DirectionalLight(0xffffff, 1.2);
          light.position.set(0.5, 1.0, 1.0).normalize();
          scene.add(light);
          scene.add(new THREE.AmbientLight(0xffffff, 0.6));

          const CAMERA_STATES = {
              head: { pos: new THREE.Vector3(0, 1.5, 0.6), target: new THREE.Vector3(0, 1.5, 0) },
              body: { pos: new THREE.Vector3(0, 1.3, 1.5), target: new THREE.Vector3(0, 1.0, 0) }
          };

          let currentTargetPos = CAMERA_STATES.head.pos.clone();
          let currentLookAt = CAMERA_STATES.head.target.clone();

          let lookAtLerp = new THREE.Vector3();

          camera.position.copy(currentTargetPos);
          camera.lookAt(currentLookAt);
          lookAtLerp.copy(currentLookAt);

          const loader = new GLTFLoader();
          loader.register((parser) => new VRMLoaderPlugin(parser));

          loader.load('./avatar.vrm',
              (gltf) => {
                  const vrm = gltf.userData.vrm;
                  vrm.scene.rotation.y = Math.PI;
                  scene.add(vrm.scene);
                  // scene.add(new THREE.AxesHelper(1));
                  window.currentVrm = vrm;

                  // Get bone positions
                  const getBonePos = (boneName) => {
                      const node = vrm.humanoid.getRawBoneNode(boneName);
                      return node ? node.getWorldPosition(new THREE.Vector3()) : null;
                  };

                  const headPos = getBonePos("head") || new THREE.Vector3(0, 1.5, 0);
                  const hipsPos = getBonePos("hips") || new THREE.Vector3(0, 0.8, 0);

                  log(`Head: ${headPos.y.toFixed(2)}, Hips: ${hipsPos.y.toFixed(2)}`);

                  // Head mode setup
                  CAMERA_STATES.head.target.copy(headPos);
                  CAMERA_STATES.head.pos.set(0, headPos.y + 0.05, 0.65);

                  // Body mode setup
                  const chestCenter = new THREE.Vector3().addVectors(headPos, hipsPos).multiplyScalar(0.5);
                  // 稍微向上偏一点，聚焦在胸口以上，避免画面重心太低
                  chestCenter.y += 0.1;

                  // 目标：看胸口
                  CAMERA_STATES.body.target.copy(chestCenter);

                  // 相机位置：
                  // 高度(Y)：为了避免俯视，相机高度应该接近颈部/下巴的高度，而不是头顶
                  const cameraY = headPos.y - 0.15;
                  // 距离(Z)：根据上半身长度估算距离，确保头和臀都在画面内
                  const upperBodyHeight = headPos.y - hipsPos.y;
                  const distanceZ = Math.max(1.4, upperBodyHeight * 2.2); // 动态计算距离

                  CAMERA_STATES.body.pos.set(0, cameraY, distanceZ);

                  setCameraMode('head', true);

                  // 隐藏调试日志
                  setTimeout(() => {
                      const el = document.getElementById('debug-console');
                      if(el) el.style.display = 'none';
                  }, 2000);
              },
              (progress) => {},
              (error) => {
                  log("❌ VRM Load Fail: " + error.message);
                  console.error(error);
              }
          );

          const clock = new THREE.Clock();
          function animate() {
              requestAnimationFrame(animate);
              const delta = clock.getDelta();
              if (window.currentVrm) window.currentVrm.update(delta);

              const damping = 0.1;

              camera.position.lerp(currentTargetPos, damping);

              lookAtLerp.lerp(currentLookAt, damping);
              camera.lookAt(lookAtLerp);

              renderer.render(scene, camera);
          }
          animate();

          window.setCameraMode = (mode, immediate = false) => {
              log("Mode: " + mode);
              const state = CAMERA_STATES[mode];
              if (state) {
                  currentTargetPos.copy(state.pos);
                  currentLookAt.copy(state.target);

                  if (immediate) {
                      camera.position.copy(currentTargetPos);
                      lookAtLerp.copy(currentLookAt);
                      camera.lookAt(lookAtLerp);
                  }
              }
          };

          window.updateSize = (w, h) => {
              camera.aspect = w / h;
              camera.updateProjectionMatrix();
              renderer.setSize(w, h);
          };

      } catch (e) {
          log("❌ Script Crash: " + e.message);
      }
    </script>
  </body>
</html>
